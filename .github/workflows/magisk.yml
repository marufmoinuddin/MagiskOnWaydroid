name: Modify Waydroid
on:
  push:
    paths-ignore:
      - 'README.md'
  pull_request:
    paths-ignore:
      - 'README.md'
  workflow_dispatch:
    inputs:
      arch:
        description: "Build arch"
        required: true
        default: "x64"
        type: choice
        options:
        - x64
      and_ver:
        description: "Android Version"
        required: true
        default: "11"
        type: choice
        options:
        - 11
      magisk_apk:
        description: "Magisk version"
        required: true
        default: "26.4"
        type: choice
        options:
        - 24.1
        - 24.2
        - 24.3
        - 25.2
        - 26.4
        - canary
        - delta
      gapps_variant:
        description: "Variants of gapps"
        required: true
        default: "pico"
        type: choice
        options:
        - none
        - super
        - stock
        - full
        - mini
        - micro
        - nano
        - pico
        - tvstock
        - tvmini
      root_sol:
        description: "Root solution"
        required: true
        default: "magisk"
        type: choice
        options:
        - magisk
        - none

jobs:
  matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Generate build matrix
        id: set-matrix
        uses: actions/github-script@v6
        with:
          script: |
            let matrix = {};
            let arch = "${{ github.event.inputs.arch }}"
            switch ( arch ) {
              case "x64":
                matrix.arch = ["x64"];
                break;
              case "arm64":
                matrix.arch = ["arm64"];
                break;
              default:
                matrix.arch = ["x64"];
                break;
            }
            let release_type = "${{ github.event.inputs.release_type }}"
            switch ( release_type ) {
              default:
                matrix.release_type = ["WIS"];
                break;
            }
            let magisk_apk = "${{ github.event.inputs.magisk_apk }}"
            switch ( magisk_apk ) {
              case "25.2":
                matrix.magisk_apk = ["25.2"];
                break;
              case "canary":
                matrix.magisk_apk = ["canary"];
                break;
              case "delta":
                matrix.magisk_apk = ["delta"];
                break;
              default:
                matrix.magisk_apk = ["26.4"];
                break;
            }
            let gapps_variant = "${{ github.event.inputs.gapps_variant }}"
            switch ( gapps_variant ) {
              default:
                matrix.gapps_variant = ["pico"];
                break;
            }
            let root_sol = "${{ github.event.inputs.root_sol }}"
            switch ( root_sol ) {
              default:
                matrix.root_sol = ["magisk"];
                break;
            }
            core.setOutput("matrix",JSON.stringify(matrix));

  build:
    runs-on: ubuntu-20.04
    needs: matrix
    strategy:
      matrix: ${{fromJson(needs.matrix.outputs.matrix)}}
    steps:
      - name: Dependencies
        run: |
          pip3 install requests beautifulsoup4 lxml tqdm
          sudo apt-get update && sudo apt-get install setools lzip qemu-utils wine winetricks patchelf attr jq -y
          wget -qO- "$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/archive/$GITHUB_REF.tar.gz" | sudo tar --wildcards -zxvf- -C ~ --strip-component=2 '*/wine/*' '*/linker/*'
          winetricks msxml6
      - name: Download WSA
        shell: python
        run: | 
          import sys
          import html
          import logging
          import re
          import zipfile
          import os
          from threading import Thread
          from typing import Any, OrderedDict
          from xml.dom import minidom
          from requests import Session
          from packaging import version
          
          
          class Prop(OrderedDict):
              def __init__(self, props: str = ...) -> None:
                  super().__init__()
                  for i, line in enumerate(props.splitlines(False)):
                      if '=' in line:
                          k, v = line.split('=', 1)
                          self[k] = v
                      else:
                          self[f".{i}"] = line
          
              def __setattr__(self, __name: str, __value: Any) -> None:
                  self[__name] = __value
          
          def download_xml(url):
              response = Session().get(url)
              if response.status_code == 200:
                  return response.text
              else:
                  raise Exception(f"Failed to download XML from {url}")
          
          def download_file(url, out_file):
              response = Session().get(url, stream=True)
              if response.status_code == 200:
                  with open(out_file, 'wb') as file:
                      for chunk in response.iter_content(chunk_size=8192):
                          file.write(chunk)
              else:
                  raise Exception(f"Failed to download file from {url}")
          
          
          logging.captureWarnings(True)
          
          # Parse command-line arguments
          # arch = sys.argv[1] if len(sys.argv) > 1 else "x64"
          # release_type = sys.argv[2] if len(sys.argv) > 2 else "retail"
          
          arch = "${{ matrix.arch }}" if len("${{ matrix.arch }}") > 1 else "x64"
          release_type = "${{ matrix.release_type }}" if len("${{ matrix.release_type }}") > 2 else "retail"
          
          release_name_map = {
              "retail": "Retail",
              "RP": "Release Preview",
              "WIS": "Insider Slow",
              "WIF": "Insider Fast" 
          }
          release_name = release_name_map.get(release_type, "Retail")
          
          cat_id = '858014f3-3934-4abe-8078-4aa193e74ca8'
          user = ''
          
          session = Session()
          session.verify = False
          
          print(f"Generating WSA download link: arch={arch} release_type={release_name}\n", flush=True)
          
          # Download XML files
          base_url = "https://raw.githubusercontent.com/LSPosed/MagiskOnWSALocal/main/xml/"
          cookie_content = download_xml(base_url + "GetCookie.xml").format(user)
          cat_id_content = download_xml(base_url + "WUIDRequest.xml").format(user, "{cookie}", cat_id, release_type)
          FE3_file_content = download_xml(base_url + "FE3FileUrl.xml")
          
          # Get cookie
          out = session.post(
              'https://fe3.delivery.mp.microsoft.com/ClientWebService/client.asmx',
              data=cookie_content,
              headers={'Content-Type': 'application/soap+xml; charset=utf-8'}
          )
          doc = minidom.parseString(out.text)
          cookie = doc.getElementsByTagName('EncryptedData')[0].firstChild.nodeValue
          
          # Get update info
          out = session.post(
              'https://fe3.delivery.mp.microsoft.com/ClientWebService/client.asmx',
              data=cat_id_content.format(cookie=cookie),
              headers={'Content-Type': 'application/soap+xml; charset=utf-8'}
          )
          
          doc = minidom.parseString(html.unescape(out.text))
          
          # Process update info
          filenames = {}
          identities = {}
          
          for node in doc.getElementsByTagName('ExtendedUpdateInfo')[0].getElementsByTagName('Updates')[0].getElementsByTagName('Update'):
              node_xml = node.getElementsByTagName('Xml')[0]
              node_files = node_xml.getElementsByTagName('Files')
              if node_files:
                  for node_file in node_files[0].getElementsByTagName('File'):
                      if node_file.hasAttribute('InstallerSpecificIdentifier') and node_file.hasAttribute('FileName'):
                          filenames[node.getElementsByTagName('ID')[0].firstChild.nodeValue] = (
                              f"{node_file.attributes['InstallerSpecificIdentifier'].value}_{node_file.attributes['FileName'].value}",
                              node_xml.getElementsByTagName('ExtendedProperties')[0].attributes['PackageIdentityName'].value
                          )
          
          for node in doc.getElementsByTagName('NewUpdates')[0].getElementsByTagName('UpdateInfo'):
              node_xml = node.getElementsByTagName('Xml')[0]
              if node_xml.getElementsByTagName('SecuredFragment'):
                  id = node.getElementsByTagName('ID')[0].firstChild.nodeValue
                  update_identity = node_xml.getElementsByTagName('UpdateIdentity')[0]
                  if id in filenames:
                      fileinfo = filenames[id]
                      if fileinfo[0] not in identities:
                          identities[fileinfo[0]] = (
                              [update_identity.attributes['UpdateID'].value, update_identity.attributes['RevisionNumber'].value],
                              fileinfo[1]
                          )
          
          download_files = {}
          
          def send_req(i, v, out_file_name):
              out = session.post(
                  'https://fe3.delivery.mp.microsoft.com/ClientWebService/client.asmx/secured',
                  data=FE3_file_content.format(user, i, v, release_type),
                  headers={'Content-Type': 'application/soap+xml; charset=utf-8'}
              )
              doc = minidom.parseString(out.text)
              for l in doc.getElementsByTagName("FileLocation"):
                  url = l.getElementsByTagName("Url")[0].firstChild.nodeValue
                  if len(url) != 99:
                      download_files[out_file_name] = url
          
          threads = []
          wsa_build_ver = 0
          
          for filename, values in identities.items():
              if re.match(f"MicrosoftCorporationII\.WindowsSubsystemForAndroid_.*\.msixbundle", filename):
                  tmp_wsa_build_ver = re.search(r'\d{4}.\d{5}.\d{1,}.\d{1,}', filename).group()
                  if wsa_build_ver == 0 or version.parse(wsa_build_ver) < version.parse(tmp_wsa_build_ver):
                      wsa_build_ver = tmp_wsa_build_ver
          
          for filename, values in identities.items():
              if re.match(f"Microsoft\.UI\.Xaml\..*_{arch}_.*\.appx", filename):
                  out_file_name = f"{values[1]}_{arch}.appx"
              elif re.match(f"Microsoft\.VCLibs\..+\.UWPDesktop_.*_{arch}_.*\.appx", filename):
                  out_file_name = f"{values[1]}_{arch}.appx"
              elif re.match(f"Microsoft\.VCLibs\..+_.*_{arch}_.*\.appx", filename):
                  out_file_name = f"{values[1]}_{arch}.appx"
              elif re.match(f"MicrosoftCorporationII\.WindowsSubsystemForAndroid_.*\.msixbundle", filename):
                  tmp_wsa_build_ver = re.search(r'\d{4}.\d{5}.\d{1,}.\d{1,}', filename).group()
                  if wsa_build_ver != tmp_wsa_build_ver:
                      continue
                  out_file_name = f"wsa-{release_type}.zip"
              else:
                  continue
              
              th = Thread(target=send_req, args=(values[0][0], values[0][1], out_file_name))
              threads.append(th)
              th.daemon = True
              th.start()
          
          for th in threads:
              th.join()
          
          print(f'WSA Build Version: {wsa_build_ver}\n')
          
          # Print download links unify download_files
          for key, value in download_files.items():
              print(f"File: {key}")
              print(f"Download link: {value}\n")
          
          # Iterate through download files and download based on the file pattern
          for key, value in download_files.items():
              if "Microsoft.UI.Xaml" in key and f"_{arch}.appx" in key:
                  filename = "xaml.appx"
              elif "wsa" in key and f"{release_type}.zip" in key:
                  filename = "wsa.zip"
              elif "Microsoft.VCLibs.140.00" in key and "UWPDesktop" not in key and f"_{arch}.appx" in key:
                  filename = "vclibs.appx"
              else:
                  continue  
          
              print(f"Downloading: {filename} from {value}")
              download_file(value, filename)
          
          # Extract and process the downloaded WSA package
          zip_name = "wsa.zip"
          try:
              with zipfile.ZipFile(zip_name, 'r') as zip_ref:
                  for f in zip_ref.filelist:
                      if arch in f.filename.lower():
                          zip_name = f.filename
                          if not os.path.isfile(zip_name):
                              print(f"Unzipping to {zip_name}", flush=True)
                              zip_ref.extract(f, ".")
                              ver_no = zip_name.split("_")
                              ver = ver_no[1]
                              with open(os.environ.get('GITHUB_ENV', '/dev/null'), 'a') as g:
                                  g.write(f'WSA_VER={ver}\n')
                              rel = ver_no[3].split(".")
                              rell = str(rel[0])
                              with open(os.environ.get('GITHUB_ENV', '/dev/null'), 'a') as g:
                                  g.write(f'WSA_REL={rell}\n')
          
                      if 'language' in f.filename.lower() or 'scale' in f.filename.lower():
                          name = f.filename.split("-", 1)[1].split(".")[0]
                          zip_ref.extract(f, '.')
                          with zipfile.ZipFile(f.filename, 'r') as l:
                              for g in l.filelist:
                                  if g.filename == 'resources.pri':
                                      g.filename = f'{name}.pri'
                                      l.extract(g, 'pri')
                                      print(f"Extracted resource pack {g.filename}")
                                  elif g.filename == 'AppxManifest.xml':
                                      g.filename = f'{name}.xml'
                                      l.extract(g, 'xml')
          
              # Extract the correct architecture file from the WSA package
              if zip_name:
                  with zipfile.ZipFile(zip_name, 'r') as zip_ref:
                      if not os.path.isdir(arch):
                          print(f"Unzipping from {zip_name}", flush=True)
                          zip_ref.extractall(arch)
          
          except (zipfile.BadZipFile, FileNotFoundError) as e:
              print(f"Error processing zip file: {e}", flush=True)
              sys.exit(1)
          
          print("Done", flush=True)
      - name: Download Magisk
        shell: python
        run: |
          import urllib.request
          import zipfile
          import os
          import json
          import requests

          magisk_apk = """${{ github.event.inputs.magisk_apk }}"""
          #magisk_apk = "canary"
          
          if not magisk_apk:
              magisk_apk = "26.4"
          if magisk_apk == "24.1":
              magisk_apk = "https://github.com/topjohnwu/Magisk/releases/download/v24.1/Magisk-v24.1.apk"
          if magisk_apk == "24.2":
              magisk_apk = "https://github.com/topjohnwu/Magisk/releases/download/v24.2/Magisk-v24.2.apk"
          if magisk_apk == "24.3":
              magisk_apk = "https://github.com/topjohnwu/Magisk/releases/download/v24.3/Magisk-v24.3.apk"
          if magisk_apk == "25.2":
              magisk_apk = "https://github.com/topjohnwu/Magisk/releases/download/v25.2/Magisk-v25.2.apk"
          if magisk_apk == "26.4":
              magisk_apk = "https://github.com/topjohnwu/Magisk/releases/download/v26.4/Magisk-v26.4.apk"
          if magisk_apk == "canary":
              magisk_apk = "https://raw.githubusercontent.com/topjohnwu/magisk-files/canary/app-debug.apk"
          if magisk_apk == "delta":
              magisk_apk = "https://huskydg.github.io/magisk-files/app-release.apk"
          if magisk_apk == "stable" or magisk_apk == "beta":
              magisk_apk = json.loads(requests.get(f"https://github.com/topjohnwu/magisk-files/raw/master/{magisk_apk}.json").content)['magisk']['link']
          

          out_file = "magisk.zip"

          arch = "${{ matrix.arch }}"

          abi_map={"x64" : ["x86_64", "x86"], "arm64" : ["arm64-v8a", "armeabi-v7a"]}

          if not os.path.isfile(out_file):
              urllib.request.urlretrieve(magisk_apk, out_file)

          def extract_as(zip, name, as_name, dir):
              info = zip.getinfo(name)
              info.filename = as_name
              zip.extract(info, dir)
              
          # changes to standalone_policy since v24.3
          # extract_as(zip, f"lib/{ abi_map[arch][0] }/libmagiskinit.so", "magiskpolicy", "magisk")
          # extract_as(zip, f"lib/{ abi_map['x64'][0] }/libmagiskinit.so", "magiskpolicy", ".")
              
          with zipfile.ZipFile(out_file) as zip:
              extract_as(zip, f"lib/{ abi_map[arch][0] }/libmagisk64.so", "magisk64", "magisk")
              extract_as(zip, f"lib/{ abi_map[arch][1] }/libmagisk32.so", "magisk32", "magisk")
              standalone_policy = False
              try:
                zip.getinfo(f"lib/{ abi_map[arch][0] }/libmagiskpolicy.so")
                standalone_policy = True
              except:
                pass
              extract_as(zip, f"lib/{ abi_map[arch][0] }/libmagiskinit.so", "magiskinit", "magisk")
              if standalone_policy:
                extract_as(zip, f"lib/{ abi_map[arch][0] }/libmagiskpolicy.so", "magiskpolicy", "magisk")
              else:
                extract_as(zip, f"lib/{ abi_map[arch][0] }/libmagiskinit.so", "magiskpolicy", "magisk")
              extract_as(zip, f"lib/{ abi_map[arch][0] }/libmagiskboot.so", "magiskboot", "magisk")
              extract_as(zip, f"lib/{ abi_map[arch][0] }/libbusybox.so", "busybox", "magisk")
              if standalone_policy:
                extract_as(zip, f"lib/{ abi_map['x64'][0] }/libmagiskpolicy.so", "magiskpolicy", ".")
              else:
                extract_as(zip, f"lib/{ abi_map['x64'][0] }/libmagiskinit.so", "magiskpolicy", ".")
              extract_as(zip, f"assets/boot_patch.sh", "boot_patch.sh", "magisk")
              extract_as(zip, f"assets/util_functions.sh", "util_functions.sh", "magisk")
      - name: Download OpenGApps
        if: ${{ matrix.gapps_variant != 'none' && matrix.gapps_variant != '' }}
        shell: python
        run: |
          import requests
          import zipfile
          import os
          import urllib.request
          import json
          import re

          arch = "${{ matrix.arch }}"
          variant = "${{ matrix.gapps_variant }}"
          abi_map = {"x64" : "x86_64", "arm64": "arm64"}
          try:
              res = requests.get(f"https://api.opengapps.org/list")
              j = json.loads(res.content)
              link = {i["name"]: i for i in j["archs"][abi_map[arch]]["apis"]["11.0"]["variants"]}[variant]["zip"]
          except Exception:
              print("Failed to fetch from opengapps api, fallbacking to sourceforge rss...")
              res = requests.get(f'https://sourceforge.net/projects/opengapps/rss?path=/{abi_map[arch]}&limit=100')
              link = re.search(f'https://.*{abi_map[arch]}/.*{variant}.*\.zip/download', res.text).group().replace('.zip/download', '.zip').replace('sourceforge.net/projects/opengapps/files', 'downloads.sourceforge.net/project/opengapps')

          print(f"downloading link: {link}", flush=True)

          out_file = "gapps.zip"

          if not os.path.isfile(out_file):
              urllib.request.urlretrieve(link, out_file)
          print("done", flush=True)

      - name : Download Waydroid System and Vendor images
        shell : python
        run : |
          import requests
          from tqdm import tqdm
          
          def download_file(url, filename):
              """Download a file from a URL with a progress bar."""
              with requests.get(url, stream=True) as r:
                  r.raise_for_status()
                  total_size = int(r.headers.get('content-length', 0))
                  with open(filename, 'wb') as f, tqdm(
                      desc=filename,
                      total=total_size,
                      unit='B',
                      unit_scale=True,
                      unit_divisor=1024,
                      miniters=1,
                      ascii=True
                  ) as bar:
                      for chunk in r.iter_content(chunk_size=1024):
                          if chunk:
                              f.write(chunk)
                              bar.update(len(chunk))
          
          # Map matrix.arch to the correct architecture suffix
          arch_suffix = ""
          arch = "${{ matrix.arch }}"
          if arch == "x64":
              arch_suffix = "x86_64"
          elif arch == "arm64":
              arch_suffix = "arm64"
          else:
              print("Unsupported architecture:", arch)
              exit(1)
          
          # Fetch and process JSON data for vendor
          vendor_json_url = f"https://raw.githubusercontent.com/waydroid/OTA/master/vendor/waydroid_{arch_suffix}/HALIUM_11.json"
          vendor_json_response = requests.get(vendor_json_url)
          vendor_json_response.raise_for_status()  # Check for request errors
          vendor_json = vendor_json_response.json()
          latest_vendor_url = next(
              (item["url"] for item in vendor_json["response"]
              if item["romtype"] == "HALIUM_11" and "vendor" in item["filename"]),
              None
          )
          
          # Fetch and process JSON data for system
          system_json_url = f"https://raw.githubusercontent.com/waydroid/OTA/master/system/lineage/waydroid_{arch_suffix}/VANILLA.json"
          system_json_response = requests.get(system_json_url)
          system_json_response.raise_for_status()  # Check for request errors
          system_json = system_json_response.json()
          latest_system_url = next(
              (item["url"] for item in system_json["response"]
              if item["romtype"] == "VANILLA" and "system" in item["filename"]),
              None
          )
          
          # Download the latest system and vendor files
          if latest_system_url:
              print(f"Downloading system file from: {latest_system_url}", flush=True)
              download_file(latest_system_url, "system.zip")
          else:
              print("No system file found")
              exit(1)
          
          if latest_vendor_url:
              print(f"Downloading vendor file from: {latest_vendor_url}", flush=True)
              download_file(latest_vendor_url, "vendor.zip")
          else:
              print("No vendor file found")
              exit(1)
              
      - name: Replace system and vendor for architecture
        run: |                 
          # Remove old images
          rm -rf ${{ matrix.arch }}/system.img ${{ matrix.arch }}/vendor.img
          
          # Extract the latest system and vendor file
          7z x system.zip -o${{ matrix.arch }}/
          7z x vendor.zip -o${{ matrix.arch }}/
          
      - name: Extract GApps and expand images
        if: ${{ matrix.gapps_variant != 'none' && matrix.gapps_variant != '' }}        
        run: |
          mkdir gapps
          unzip -p gapps.zip {Core,GApps}/'*.lz' | tar --lzip -C gapps -xvf - -i --strip-components=2 --exclude='setupwizardtablet-x86_64' --exclude='packageinstallergoogle-all' --exclude='speech-common' --exclude='markup-lib-arm' --exclude='markup-lib-arm64' --exclude='markup-all' --exclude='setupwizarddefault-x86_64' --exclude='pixellauncher-all' --exclude='pixellauncher-common'
          e2fsck -yf ${{ matrix.arch }}/system.img
          resize2fs ${{ matrix.arch }}/system.img $(( $(du -sB512 gapps | cut -f1) + $(du -sB512 ${{ matrix.arch }}/system.img | cut -f1) ))s
      - name: Expand vendor
        run: |
          e2fsck -yf ${{ matrix.arch }}/vendor.img
          resize2fs ${{ matrix.arch }}/vendor.img 512M
      - name: Mount images
        run: |
          sudo mkdir system
          sudo mkdir userdata
          sudo mount -o loop ${{ matrix.arch }}/system.img system
          sudo mount -o loop ${{ matrix.arch }}/vendor.img system/vendor
          sudo mv system/product system/product_ln
          sudo mkdir system/product
          sudo mount --bind $(pwd)/system/system/product $(pwd)/system/product
          ls system/product
          sudo mv system/system_ext system/system_ext_ln
          sudo mkdir system/system_ext
          sudo mount --bind $(pwd)/system/system/system_ext $(pwd)/system/system_ext
          ls system/system_ext
          qemu-img convert -O raw ${{ matrix.arch }}/userdata.vhdx userdata.img
          sudo mount -o loop userdata.img userdata
      - name: Integrate Magisk
        if: ${{ github.event.inputs.root_sol == 'magisk' || github.event.inputs.root_sol == '' }}        
        run: |
          mkdir linker
          mkdir linker/x86_64
          wget -q https://raw.githubusercontent.com/marufmoinuddin/MagiskOnWaydroid/main/linker/x86_64/libc.so -O linker/x86_64/libc.so
          wget -q https://raw.githubusercontent.com/marufmoinuddin/MagiskOnWaydroid/main/linker/x86_64/libdl.so -O linker/x86_64/libdl.so
          wget -q https://raw.githubusercontent.com/marufmoinuddin/MagiskOnWaydroid/main/linker/x86_64/libm.so -O linker/x86_64/libm.so
          wget -q https://raw.githubusercontent.com/marufmoinuddin/MagiskOnWaydroid/main/linker/x86_64/linker64 -O linker/x86_64/linker64
          
          sudo chmod +x "linker/x86_64/linker64" || abort
          sudo patchelf --set-interpreter "linker/x86_64/linker64" "magisk/magiskpolicy" || abort
          chmod +x "magisk/magiskpolicy" || abort
          
          sudo cp "magisk/magisk"* "system/debug_ramdisk/"
          sudo cp magisk.zip "system/debug_ramdisk/stub.apk" || abort
          
          sudo tee -a "system/debug_ramdisk/loadpolicy.sh" <<EOF >/dev/null || abort
          #!/system/bin/sh
          MAGISKTMP=/debug_ramdisk
          export MAGISKTMP
          mkdir -p /data/adb/magisk
          cp \$MAGISKTMP/* /data/adb/magisk/
          sync
          chmod -R 755 /data/adb/magisk
          restorecon -R /data/adb/magisk
          MAKEDEV=1 \$MAGISKTMP/magisk --preinit-device 2>&1
          RULESCMD=""
          for r in \$MAGISKTMP/.magisk/preinit/*/sepolicy.rule; do
            [ -f "\$r" ] || continue
            RULESCMD="\$RULESCMD --apply \$r"
          done
          \$MAGISKTMP/magiskpolicy --live \$RULESCMD 2>&1
          EOF
          sudo find "system/debug_ramdisk" -type f -exec chmod 0711 {} \;
          sudo find "system/debug_ramdisk" -type f -exec chown root:root {} \;
          sudo find "system/debug_ramdisk" -type f -exec setfattr -n security.selinux -v "u:object_r:magisk_file:s0" {} \; || abort
          echo "/debug_ramdisk(/.*)?    u:object_r:magisk_file:s0" | sudo tee -a "system/vendor/etc/selinux/vendor_file_contexts"
          echo '/data/adb/magisk(/.*)?   u:object_r:magisk_file:s0' | sudo tee -a "system/vendor/etc/selinux/vendor_file_contexts"
          #ls -R .
          sudo LD_LIBRARY_PATH="linker/x86_64" "magisk/magiskpolicy" --load "system/vendor/etc/selinux/precompiled_sepolicy" --save "system/vendor/etc/selinux/precompiled_sepolicy" --magisk || abort

          
          sudo tee -a "system/system/etc/init/hw/init.rc" <<EOF >/dev/null
          on post-fs-data
              mkdir /dev/debug_ramdisk_mirror
              mount none /debug_ramdisk /dev/debug_ramdisk_mirror bind
              mount none none /dev/debug_ramdisk_mirror private
              mount tmpfs magisk /debug_ramdisk mode=0755
              copy /dev/debug_ramdisk_mirror/magisk64 /debug_ramdisk/magisk64
              chmod 0755 /debug_ramdisk/magisk64
              symlink ./magisk64 /debug_ramdisk/magisk
              symlink ./magisk64 /debug_ramdisk/su
              symlink ./magisk64 /debug_ramdisk/resetprop
              start adbd
              copy /dev/debug_ramdisk_mirror/magisk32 /debug_ramdisk/magisk32
              chmod 0755 /debug_ramdisk/magisk32
              copy /dev/debug_ramdisk_mirror/magiskinit /debug_ramdisk/magiskinit
              chmod 0750 /debug_ramdisk/magiskinit
              copy /dev/debug_ramdisk_mirror/magiskpolicy /debug_ramdisk/magiskpolicy
              chmod 0755 /debug_ramdisk/magiskpolicy
              mkdir /debug_ramdisk/.magisk
              mkdir /debug_ramdisk/.magisk/mirror 0
              mkdir /debug_ramdisk/.magisk/block 0
              mkdir /debug_ramdisk/.magisk/worker 0
              copy /dev/debug_ramdisk_mirror/stub.apk /debug_ramdisk/stub.apk
              chmod 0644 /debug_ramdisk/stub.apk
              copy /dev/debug_ramdisk_mirror/loadpolicy.sh /debug_ramdisk/loadpolicy.sh
              chmod 0755 /debug_ramdisk/loadpolicy.sh
              umount /dev/debug_ramdisk_mirror
              rmdir /dev/debug_ramdisk_mirror
              exec u:r:magisk:s0 0 0 -- /system/bin/sh /debug_ramdisk/loadpolicy.sh
              exec u:r:magisk:s0 0 0 -- /debug_ramdisk/magisk --post-fs-data

          on property:vold.decrypt=trigger_restart_framework
              exec u:r:magisk:s0 0 0 -- /debug_ramdisk/magisk --service

          on nonencrypted
              exec u:r:magisk:s0 0 0 -- /debug_ramdisk/magisk --service

          on property:sys.boot_completed=1
              exec u:r:magisk:s0 0 0 --  /debug_ramdisk/magisk --boot-complete

          on property:init.svc.zygote=stopped
              exec u:r:magisk:s0 0 0 -- /debug_ramdisk/magisk --zygote-restart
          EOF
          
          for i in "system/system/etc/init/hw"/*; do
              if [[ "$i" =~ init.zygote.+\.rc ]]; then
                  echo "Inject zygote restart $i"
                  sudo awk -i inplace '{if($0 ~ /service zygote /){print $0;print "    exec u:r:magisk:s0 0 0 -- /debug_ramdisk/magisk --zygote-restart";a="";next}} 1' "$i"
                  sudo setfattr -n security.selinux -v "u:object_r:system_file:s0" "$i" || abort
              fi
          done

          echo -e "Integrate Magisk done\n"
      - name: Remove FOSS Apps        
        run: |
          sudo rm -rf system/system/app/com.google.android.gsf
          sudo rm -rf system/system/app/com.aurora.adroid
          sudo rm -rf system/system/app/com.aurora.store
          sudo rm -rf system/system/app/com.etesync.syncadapter
          sudo rm -rf system/system/app/is.xyz.mpv
          sudo rm -rf system/system/app/me.jfenn.alarmio
          sudo rm -rf system/system/app/org.microg.gms.droidguard
          sudo rm -rf system/system/app/org.microg.nlp.backend.ichnaea
          sudo rm -rf system/system/app/org.microg.nlp.backend.nominatim
          sudo rm -rf system/system/app/org.schabi.newpipe
          sudo rm -rf system/system/app/ws.xsoh.etar
          sudo rm -rf system/system/priv-app/AuroraServices_v1.1.1
          sudo rm -rf system/system/priv-app/com.google.android.gms
          sudo rm -rf system/system/priv-app/com.android.vending
          sudo rm -rf system/system/product/app/Etar
          sudo rm -rf system/system/product/priv-app/Contacts
          sudo rm -rf system/system/product/app/ExactCalculator
          sudo rm -rf system/system/product/priv-app/Eleven
          sudo rm -rf system/system/app/com.simplemobiletools.gallery.pro
          sudo rm -rf system/system/app/NotePad
          sudo rm -rf system/system/app/org.bromite.bromite
          sudo rm -rf system/system/app/com.google.android.webview
          sudo rm -rf system/system/app/com.android.webview
          #sudo mv system/system/xbin/su system/system/xbin/suold
          sudo ls system/system/xbin
          wget -qO- "$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/archive/$GITHUB_REF.tar.gz" | sudo tar --wildcards -zxvf- --strip-component=2 '*/${{ matrix.arch }}/system/*'
          sudo find system/system/priv-app -type d -exec chmod 0755 {} \;
          sudo find system/system/priv-app -type f -exec chmod 0644 {} \;
          sudo find system/system/priv-app -exec chcon --reference=system/system/priv-app {} \;
      - name: Fix GApps prop
        if: ${{ matrix.gapps_variant != 'none' && matrix.gapps_variant != '' }}
        shell: sudo python {0}
        run: |
          from __future__ import annotations
          from io import TextIOWrapper
          from os import system
          from typing import OrderedDict


          class Prop(OrderedDict):
              def __init__(self, file: TextIOWrapper) -> None:
                  super().__init__()
                  for i, line in enumerate(file.read().splitlines(False)):
                      if '=' in line:
                          k, v = line.split('=', 2)
                          self[k] = v
                      else:
                          self[f".{i}"] = line

              def __str__(self) -> str:
                  return '\n'.join([v if k.startswith('.') else f"{k}={v}" for k, v in self.items()])

              def __iadd__(self, other: str) -> Prop:
                  self[f".{len(self)}"] = other
                  return self


          new_props = {
              ("product", "brand"): "google",
              ("product", "manufacturer"): "Google",
              ("build", "product"): "redfin",
              ("product", "name"): "redfin",
              ("product", "device"): "redfin",
              ("product", "model"): "Pixel 5",
              ("build", "flavor"): "redfin-user"
          }


          def description(sec: str, p: Prop) -> str:
              return f"{p[f'ro.{sec}.build.flavor']} {p[f'ro.{sec}.build.version.release_or_codename']} {p[f'ro.{sec}.build.id']} {p[f'ro.{sec}.build.version.incremental']} {p[f'ro.{sec}.build.tags']}"


          def fingerprint(sec: str, p: Prop) -> str:
              return f"""{p[f"ro.product.{sec}.brand"]}/{p[f"ro.product.{sec}.name"]}/{p[f"ro.product.{sec}.device"]}:{p[f"ro.{sec}.build.version.release"]}/{p[f"ro.{sec}.build.id"]}/{p[f"ro.{sec}.build.version.incremental"]}:{p[f"ro.{sec}.build.type"]}/{p[f"ro.{sec}.build.tags"]}"""


          def fix_prop(sec, prop):
              print(f"fixing {prop}", flush=True)
              with open(prop, 'r') as f:
                  p = Prop(f)

              p += "# extra prop added by MagiskOnWSA"

              for k, v in new_props.items():
                  p[f"ro.{k[0]}.{k[1]}"] = v
                  
                  if k[0] == "build":
                      p[f"ro.{sec}.{k[0]}.{k[1]}"] = v
                  elif k[0] == "product":
                      p[f"ro.{k[0]}.{sec}.{k[1]}"] = v

              p["ro.build.description"] = description(sec, p)
              p[f"ro.build.fingerprint"] = fingerprint(sec, p)
              p[f"ro.{sec}.build.description"] = description(sec, p)
              p[f"ro.{sec}.build.fingerprint"] = fingerprint(sec, p)
              p[f"ro.bootimage.build.fingerprint"] = fingerprint(sec, p)

              with open(prop, 'w') as f:
                  f.write(str(p))

          for sec, prop in {"system": "system/system/build.prop", "product": "system/product/build.prop", "system_ext": "system/system_ext/build.prop", "vendor": "system/vendor/build.prop", "odm": "system/vendor/odm/etc/build.prop"}.items():
              fix_prop(sec, prop)
      - name: Umount images
        
        run: |
          sudo umount system/vendor
          sudo umount -l system/product
          sudo rm -rf system/product
          sudo mv system/product_ln system/product
          sudo umount -l system/system_ext
          sudo rm -rf system/system_ext
          sudo mv system/system_ext_ln system/system_ext
          sudo umount system
          sudo umount userdata
          qemu-img convert -o subformat=dynamic -f raw -O vhdx userdata.img ${{ matrix.arch }}/userdata.vhdx
      - name: Shrink images
        run: |
          e2fsck -yf ${{ matrix.arch }}/system.img
          resize2fs -M ${{ matrix.arch }}/system.img
          e2fsck -yf ${{ matrix.arch }}/vendor.img
          resize2fs -M ${{ matrix.arch }}/vendor.img
      - name: Remove signature and add scripts
        run: |
          rm -rf ${{ matrix.arch }}/product.img
          rm -rf ${{ matrix.arch }}/system_ext.img
          rm -rf ${{ matrix.arch }}/userdata.img
          rm -rf WsaPackage_*_ARM64_Release-Nightly.msix
          rm -rf WsaPackage_*_language*.msix
          rm -rf ${{ matrix.arch }}/\[Content_Types\].xml ${{ matrix.arch }}/AppxBlockMap.xml ${{ matrix.arch }}/AppxSignature.p7x ${{ matrix.arch }}/AppxMetadata
          cp vclibs.appx xaml.appx ${{ matrix.arch }}
          tee ${{ matrix.arch }}/Install.ps1 <<EOF
          # Automated Install script by Mioki
          # http://github.com/okibcn
          function Test-Administrator {
              [OutputType([bool])]
              param()
              process {
                  [Security.Principal.WindowsPrincipal]\$user = [Security.Principal.WindowsIdentity]::GetCurrent();
                  return \$user.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator);
              }
          }

          function Finish {
              Clear-Host
              Start-Process "wsa://com.topjohnwu.magisk"
              Start-Process "wsa://com.android.vending"
          }

          if (-not (Test-Administrator)) {
              \$proc = Start-Process -PassThru -WindowStyle Hidden -Verb RunAs powershell.exe -Args "-executionpolicy bypass -command Set-Location '\$PSScriptRoot'; &'\$PSCommandPath' EVAL"
              \$proc.WaitForExit()
              if (\$proc.ExitCode -ne 0) {
                  Clear-Host
                  Write-Warning "Failed to launch start as Administrator\`r\`nPress any key to exit"
                  \$null = \$Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown');
              }
              exit
          }
          elseif ((\$args.Count -eq 1) -and (\$args[0] -eq "EVAL")) {
              Start-Process powershell.exe -Args "-executionpolicy bypass -command Set-Location '\$PSScriptRoot'; &'\$PSCommandPath'"
              exit
          }

          if (((Test-Path -Path $(ls -Q ./${{ matrix.arch }} | paste -sd "," -)) -eq \$false).Count) {
              Write-Error "Some files are missing in the zip. Please try to download it again from the browser downloader, or try to run the workflow again. Press any key to exist"
              \$null = \$Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
              exit 1
          }
          
          reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AppModelUnlock" /t REG_DWORD /f /v "AllowDevelopmentWithoutDevLicense" /d "1"

          \$VMP = Get-WindowsOptionalFeature -Online -FeatureName 'VirtualMachinePlatform'
          if (\$VMP.State -ne "Enabled") {
              Enable-WindowsOptionalFeature -Online -NoRestart -FeatureName 'VirtualMachinePlatform'
              Clear-Host
              Write-Warning "Need restart to enable virtual machine platform\`r\`nPress y to restart or press any key to exit"
              \$key = \$Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
              If ("y" -eq \$key.Character) {
                  Restart-Computer -Confirm
              }
              Else {
                  exit 1
              }
          }

          Add-AppxPackage -ForceApplicationShutdown -ForceUpdateFromAnyVersion -Path vclibs.appx
          Add-AppxPackage -ForceApplicationShutdown -ForceUpdateFromAnyVersion -Path xaml.appx

          \$Installed = \$null
          \$Installed = Get-AppxPackage -Name 'MicrosoftCorporationII.WindowsSubsystemForAndroid'

          If ((\$null -ne \$Installed) -and (-not (\$Installed.IsDevelopmentMode))) {
              Clear-Host
              Write-Warning "There is already one installed WSA. Please uninstall it first.\`r\`nPress y to uninstall existing WSA or press any key to exit"
              \$key = \$Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
              If ("y" -eq \$key.Character) {
                  Remove-AppxPackage -Package \$Installed.PackageFullName
              }
              Else {
                  exit 1
              }
          }
          Clear-Host
          Write-Host "Installing MagiskOnWSA..."
          Stop-Process -Name "wsaclient" -ErrorAction "silentlycontinue"
          Add-AppxPackage -ForceApplicationShutdown -ForceUpdateFromAnyVersion -Register .\AppxManifest.xml
          if (\$?) {
              Finish
          }
          Elseif (\$null -ne \$Installed) {
              Clear-Host
              Write-Host "Failed to update, try to uninstall existing installation while preserving userdata..."
              Remove-AppxPackage -PreserveApplicationData -Package \$Installed.PackageFullName
              Add-AppxPackage -ForceApplicationShutdown -ForceUpdateFromAnyVersion -Register .\AppxManifest.xml
              if (\$?) {
                  Finish
              }
          }
          Write-Host "All Done\`r\`nPress any key to exit"
          \$null = \$Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
          EOF
          shopt -s extglob
          sudo rm -rf -- ${{ matrix.arch }}/!(system.img|vendor.img)
      - name: Generate artifact name        
        run: |
          variant="${{ matrix.gapps_variant }}"
          root="${{ github.event.inputs.root_sol }}"
          if [[ "$root" = "none" ]]; then
            name1=""
          elif [[ "$root" = "" ]]; then
            name1="-magisk"
          else
            name1="-${root}"
          fi
          if [[ "$variant" = "none" || "$variant" = "" ]]; then
            name2="-NoGApps"
          else
            name2="-${variant}"
          fi
          echo "artifact_name=WD${name1}${name2}_${{ matrix.arch }}" >> $GITHUB_ENV
      - name: Upload 
        uses: actions/upload-artifact@v2
        with:
          name: ${{ env.artifact_name }}
          path: "./${{ matrix.arch }}/*"
